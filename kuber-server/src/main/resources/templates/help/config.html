<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head th:replace="~{layout :: head('Configuration')}"></head>
<body class="d-flex flex-column min-vh-100">
<nav th:replace="~{layout :: navbar}"></nav>
<main class="flex-fill">
    <div class="container-fluid py-4">
        <nav aria-label="breadcrumb" class="mb-4">
            <ol class="breadcrumb">
                <li class="breadcrumb-item"><a href="/help"><i class="fas fa-book me-1"></i>Help</a></li>
                <li class="breadcrumb-item active">Configuration</li>
            </ol>
        </nav>
        <div class="row">
            <div class="col-lg-10 mx-auto">
                <h1 class="display-5 mb-4"><i class="fas fa-cog text-secondary me-3"></i>Configuration</h1>

                <h3>Key Properties</h3>
                <pre class="bg-dark text-light p-3 rounded"><code># Network
kuber.network.port=6379
server.port=8080

# Persistence (rocksdb, lmdb, mongodb, postgresql, sqlite, memory)
kuber.persistence.type=lmdb

# Individual Write Mode (v1.5.0)
# false = ASYNC (default): Memory first, disk in background - faster
# true = SYNC: Wait for disk write - more durable
kuber.persistence.sync-individual-writes=false

# RocksDB Configuration
kuber.persistence.rocksdb.path=./data/rocksdb
kuber.persistence.rocksdb.compaction-enabled=true
kuber.persistence.rocksdb.compaction-cron=0 0 2 * * ?

# LMDB Configuration (v1.2.2)
kuber.persistence.lmdb.path=./data/lmdb
kuber.persistence.lmdb.map-size=1073741824  # 1GB

# SQLite (each region gets separate database file)
kuber.persistence.sqlite.path=./data/sqlite

# Cache Memory Management (v1.2.2)
kuber.cache.max-memory-entries=100000           # Default per-region limit
kuber.cache.global-max-memory-entries=500000    # Global cap across all regions (0=unlimited)
kuber.cache.region-memory-limits.customers=50000   # Per-region override
kuber.cache.region-memory-limits.products=200000   # Per-region override
kuber.cache.persistent-mode=true

# Off-Heap Key Index (v1.2.2) - Zero GC pressure for key storage
kuber.cache.off-heap-key-index=false            # Enable off-heap key storage
kuber.cache.off-heap-key-index-initial-size-mb=16  # Initial buffer per region
kuber.cache.off-heap-key-index-max-size-mb=1024    # Max buffer per region

# Autoload with Batch Writes (v1.3.9)
kuber.autoload.enabled=true
kuber.autoload.directory=./data/autoload
kuber.autoload.batch-size=8192  # Records per batch for bulk loading

# Backup and Restore (v1.5.0)
kuber.backup.enabled=true                    # Enable backup/restore service
kuber.backup.backup-directory=./backup       # Where backup files are stored
kuber.backup.restore-directory=./restore     # Monitor for restore files
kuber.backup.cron=0 0 23 * * *               # Schedule: 11 PM daily (default)
kuber.backup.max-backups-per-region=10       # Retention (0 = keep all)
kuber.backup.compress=true                   # Gzip compression
kuber.backup.batch-size=10000               # Entries per batch</code></pre>
                
                <div class="alert alert-info mt-3">
                    <i class="fas fa-database me-2"></i>
                    <strong>Backup/Restore (v1.5.0):</strong> Automatic scheduled backup using cron expressions (default: 11 PM daily). Place backup files in <code>./restore</code> to trigger automatic restore. Regions are locked during restore. Use Admin Dashboard for manual backup. See <a href="/help/backup">Backup & Restore</a> for details.
                </div>
                
                <div class="alert alert-success mt-3">
                    <i class="fas fa-bolt me-2"></i>
                    <strong>Async Writes (v1.3.10):</strong> Individual PUT/SET operations now use async mode by default. Memory is updated immediately, disk write happens in background. 10-100x faster than sync mode. Set <code>sync-individual-writes=true</code> for maximum durability.
                </div>
                
                <div class="alert alert-warning mt-3">
                    <i class="fas fa-microchip me-2"></i>
                    <strong>Off-Heap Key Index (v1.2.2):</strong> Store keys in DRAM outside Java heap for zero GC pressure. Enable with <code>off-heap-key-index=true</code>. Keys are stored in direct ByteBuffer memory, eliminating GC scans for key storage. Ideal for millions of keys.
                </div>
                
                <div class="alert alert-primary mt-3">
                    <i class="fas fa-memory me-2"></i>
                    <strong>Hybrid Memory Architecture (v1.2.1):</strong> All keys are ALWAYS kept in memory via KeyIndex. EXISTS and KEYS operations NEVER hit disk - pure O(1) memory lookups. Values can overflow to disk when memory is constrained while keys remain instantly accessible.
                </div>
                
                <div class="alert alert-success mt-3">
                    <i class="fas fa-bolt me-2"></i>
                    <strong>LMDB Persistence (v1.2.0):</strong> Lightning Memory-Mapped Database support with zero-copy reads, ACID transactions, and crash-safe operation. Ideal for read-heavy workloads.
                </div>
                
                <div class="alert alert-info mt-3">
                    <i class="fas fa-database me-2"></i>
                    <strong>Six Storage Backends:</strong> Choose from RocksDB (default), LMDB, MongoDB, PostgreSQL, SQLite, or in-memory storage based on your needs.
                </div>
                
                <div class="alert alert-info mt-3">
                    <i class="fas fa-info-circle me-2"></i>
                    <strong>Region Isolation (v1.2.2):</strong> RocksDB, LMDB, and SQLite use separate database instances per region for improved concurrency and isolation. Each region has its own directory/file under the configured path.
                </div>
                
                <div class="alert alert-success mt-3">
                    <i class="fas fa-memory me-2"></i>
                    <strong>Smart Memory Allocation (v1.2.2):</strong> When <code>global-max-memory-entries</code> is set and total configured limits exceed the global cap, Kuber uses smart proportional allocation based on 50% configured limits and 50% actual data size.
                </div>
                
                <div class="alert alert-warning mt-3">
                    <i class="fas fa-broom me-2"></i>
                    <strong>Pre-Startup Maintenance (v1.2.2):</strong> 
                    <ul class="mb-0 mt-2">
                        <li><strong>RocksDB:</strong> Compaction runs automatically BEFORE Spring context starts</li>
                        <li><strong>SQLite:</strong> VACUUM runs automatically BEFORE Spring context starts</li>
                        <li><strong>Benefit:</strong> No resource contention - databases are optimized before any web requests</li>
                    </ul>
                </div>
                
                <div class="alert alert-info mt-3">
                    <i class="fas fa-clock me-2"></i>
                    <strong>Scheduled Maintenance (v1.2.2):</strong> 
                    <ul class="mb-0 mt-2">
                        <li><strong>RocksDB:</strong> Additional compaction on cron schedule (default: <code>0 0 2 * * ?</code> = 2 AM daily)</li>
                        <li><strong>Manual:</strong> Trigger compaction via API: <code>POST /api/monitoring/compaction/trigger</code></li>
                    </ul>
                    <div class="mt-2">
                        <strong>Cron Examples:</strong>
                        <ul class="mb-0">
                            <li><code>0 0 2 * * ?</code> - 2:00 AM daily</li>
                            <li><code>0 0 3 * * SUN</code> - 3:00 AM every Sunday</li>
                            <li><code>0 0 1,13 * * ?</code> - 1:00 AM and 1:00 PM daily</li>
                            <li><code>0 0 */6 * * ?</code> - Every 6 hours</li>
                        </ul>
                    </div>
                </div>
                
                <div class="alert alert-primary mt-3">
                    <i class="fas fa-tachometer-alt me-2"></i>
                    <strong>Fast Entry Counts (v1.2.2):</strong> Dashboard and UI pages use O(1) fast estimates from RocksDB native properties. This ensures instant page loads even with millions of entries. The counts are approximate but highly accurate for typical use cases.
                </div>
                
                <h3 class="mt-4">Security</h3>
                <pre class="bg-dark text-light p-3 rounded"><code>kuber.security.admin-username=admin
kuber.security.admin-password=admin123</code></pre>
                <div class="mt-5 text-center">
                    <a href="/help" class="btn btn-outline-primary"><i class="fas fa-arrow-left me-2"></i>Back to Help Index</a>
                </div>
            </div>
        </div>
        <footer class="py-4 mt-5 border-top">
            <div class="row">
                <div class="col-md-6"><h6><i class="fas fa-database me-2"></i><span th:text="${appName} ?: 'Kuber'">Kuber</span></h6><p class="text-muted small mb-0">Version 1.7.7</p></div>
                <div class="col-md-6 text-end"><p class="text-muted small mb-0">Copyright &copy; 2025-2030 Ashutosh Sinha<br><span class="badge bg-warning text-dark">Patent Pending</span></p></div>
            </div>
        </footer>
    </div>
</main>
<th:block th:replace="~{layout :: scripts}"></th:block>
</body>
</html>