<!DOCTYPE html>
<!--
  ~ Copyright © 2025-2030, All Rights Reserved
  ~ Ashutosh Sinha | Email: ajsinha@gmail.com
  ~ Patent Pending: Hybrid Secondary Index Architecture
  -->
<html xmlns:th="http://www.thymeleaf.org">
<head th:replace="~{layout :: head('Secondary Indexing - ' + (${appName} ?: 'Kuber'))}"></head>
<body class="d-flex flex-column min-vh-100">

<nav th:replace="~{layout :: navbar}"></nav>

<main class="flex-fill">
    <div class="container-fluid py-4">
        <!-- Breadcrumb -->
        <nav aria-label="breadcrumb" class="mb-4">
            <ol class="breadcrumb">
                <li class="breadcrumb-item"><a href="/help"><i class="fas fa-book me-1"></i>Help</a></li>
                <li class="breadcrumb-item active" aria-current="page">Secondary Indexing</li>
            </ol>
        </nav>
        
        <div class="row">
            <!-- Main Content -->
            <div class="col-lg-10 mx-auto">
                <div class="card shadow-sm">
                    <div class="card-header bg-primary text-white">
                        <h4 class="mb-0"><i class="fas fa-list-alt me-2"></i>Secondary Indexing (v2.2.0)</h4>
                    </div>
                    <div class="card-body">
                        
                        <!-- Introduction -->
                        <div class="alert alert-info">
                            <i class="fas fa-lightbulb me-2"></i>
                            <strong>New in v2.2.0:</strong> Secondary indexes provide O(1) hash lookups, O(log n) range queries,
                            and now <strong>TRIGRAM indexes for fast regex/pattern searches</strong> on JSON attributes - 
                            delivering <strong>100-1000x performance improvements</strong> over full table scans.
                        </div>
                        
                        <!-- Overview -->
                        <h5 class="mt-4"><i class="fas fa-info-circle me-2 text-primary"></i>Overview</h5>
                        <p>
                            Kuber's secondary indexing system uses a <strong>hybrid architecture</strong> that combines:
                        </p>
                        <ul>
                            <li><strong>In-Memory Indexes</strong>: Hash maps, B-trees, Trigram indexes, and Tries stored in memory for fastest possible lookups</li>
                            <li><strong>RocksDB Persistence</strong>: Indexes persisted to RocksDB for durability across restarts</li>
                            <li><strong>Automatic Maintenance</strong>: Indexes updated transparently on every INSERT, UPDATE, DELETE operation</li>
                            <li><strong>Smart Query Planning</strong>: Automatically selects the best index for each query type</li>
                        </ul>
                        
                        <div class="alert alert-success">
                            <i class="fas fa-magic me-2"></i>
                            <strong>Four Index Types:</strong>
                            <span class="badge bg-primary">HASH</span> for equality,
                            <span class="badge bg-success">BTREE</span> for ranges,
                            <span class="badge bg-warning text-dark">TRIGRAM</span> for regex/contains,
                            <span class="badge bg-info">PREFIX</span> for starts-with
                        </div>
                        
                        <!-- Performance Comparison -->
                        <h5 class="mt-4"><i class="fas fa-tachometer-alt me-2 text-success"></i>Performance Comparison</h5>
                        <table class="table table-bordered table-sm">
                            <thead class="table-dark">
                                <tr>
                                    <th>Query Type</th>
                                    <th>Without Index (Full Scan)</th>
                                    <th>With Index</th>
                                    <th>Speedup</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code>status = "active"</code></td>
                                    <td>O(n) - 8,450ms for 100K docs</td>
                                    <td>O(1) HASH - 5ms</td>
                                    <td class="table-success"><strong>1,690x</strong></td>
                                </tr>
                                <tr>
                                    <td><code>age &gt; 30</code></td>
                                    <td>O(n) - 8,450ms</td>
                                    <td>O(log n + k) BTREE - 45ms</td>
                                    <td class="table-success"><strong>188x</strong></td>
                                </tr>
                                <tr>
                                    <td><code>status = "active" AND city = "NYC"</code></td>
                                    <td>O(n) - 8,450ms</td>
                                    <td>O(min(m,n)) HASH - 12ms</td>
                                    <td class="table-success"><strong>704x</strong></td>
                                </tr>
                                <tr>
                                    <td><code>created_at BETWEEN '2025-01-01' AND '2025-06-30'</code></td>
                                    <td>O(n) - 8,450ms</td>
                                    <td>O(log n + k) BTREE - 85ms</td>
                                    <td class="table-success"><strong>99x</strong></td>
                                </tr>
                                <tr class="table-warning">
                                    <td><code>email MATCHES ".*@gmail\.com$"</code></td>
                                    <td>O(n) - 8,450ms</td>
                                    <td>O(trigrams) TRIGRAM - 8ms</td>
                                    <td class="table-success"><strong>1,056x</strong></td>
                                </tr>
                                <tr class="table-warning">
                                    <td><code>name CONTAINS "smith"</code></td>
                                    <td>O(n) - 8,450ms</td>
                                    <td>O(trigrams) TRIGRAM - 12ms</td>
                                    <td class="table-success"><strong>704x</strong></td>
                                </tr>
                                <tr class="table-info">
                                    <td><code>sku STARTS WITH "NYC-"</code></td>
                                    <td>O(n) - 8,450ms</td>
                                    <td>O(prefix len) PREFIX - 3ms</td>
                                    <td class="table-success"><strong>2,817x</strong></td>
                                </tr>
                            </tbody>
                        </table>
                        <p class="small text-muted">* Benchmarks on 100,000 JSON documents, 8 CPU cores</p>
                        
                        <!-- Index Types -->
                        <h5 class="mt-4"><i class="fas fa-database me-2 text-info"></i>Index Types</h5>
                        
                        <div class="row">
                            <div class="col-md-6">
                                <div class="card border-primary mb-3">
                                    <div class="card-header bg-primary text-white">
                                        <strong>HASH Index</strong>
                                    </div>
                                    <div class="card-body">
                                        <p><strong>Best for:</strong> Equality queries</p>
                                        <p><strong>Complexity:</strong> O(1) lookup</p>
                                        <p><strong>Use when:</strong></p>
                                        <ul class="small">
                                            <li><code>status = "active"</code></li>
                                            <li><code>city = "NYC"</code></li>
                                            <li><code>category IN ["A", "B", "C"]</code></li>
                                            <li>Low-to-medium cardinality fields</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="card border-success mb-3">
                                    <div class="card-header bg-success text-white">
                                        <strong>BTREE Index</strong>
                                    </div>
                                    <div class="card-body">
                                        <p><strong>Best for:</strong> Range queries</p>
                                        <p><strong>Complexity:</strong> O(log n) lookup</p>
                                        <p><strong>Use when:</strong></p>
                                        <ul class="small">
                                            <li><code>age &gt; 30</code></li>
                                            <li><code>price BETWEEN 100 AND 500</code></li>
                                            <li><code>created_at &gt; "2025-01-01"</code></li>
                                            <li>Numeric or date fields</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- TRIGRAM and PREFIX indexes -->
                        <div class="row">
                            <div class="col-md-6">
                                <div class="card border-warning mb-3">
                                    <div class="card-header bg-warning text-dark">
                                        <strong>TRIGRAM Index</strong> <span class="badge bg-dark ms-2">v2.2.0</span>
                                    </div>
                                    <div class="card-body">
                                        <p><strong>Best for:</strong> Regex, substring, pattern searches</p>
                                        <p><strong>Complexity:</strong> O(trigram matches) - typically very fast</p>
                                        <p><strong>Use when:</strong></p>
                                        <ul class="small">
                                            <li><code>email MATCHES ".*@gmail\.com$"</code></li>
                                            <li><code>name CONTAINS "smith"</code></li>
                                            <li><code>sku MATCHES "^SKU-[0-9]{4}.*"</code></li>
                                            <li>Any field needing regex/pattern searches</li>
                                        </ul>
                                        <div class="alert alert-warning small mb-0 mt-2">
                                            <i class="fas fa-info-circle me-1"></i>
                                            <strong>How it works:</strong> Breaks values into 3-char sequences (trigrams), 
                                            extracts literals from regex, then intersects posting lists to find candidates.
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="card border-info mb-3">
                                    <div class="card-header bg-info text-white">
                                        <strong>PREFIX Index</strong> <span class="badge bg-light text-dark ms-2">v2.2.0</span>
                                    </div>
                                    <div class="card-body">
                                        <p><strong>Best for:</strong> Prefix/starts-with queries</p>
                                        <p><strong>Complexity:</strong> O(prefix length) lookup</p>
                                        <p><strong>Use when:</strong></p>
                                        <ul class="small">
                                            <li><code>sku STARTS WITH "NYC-"</code></li>
                                            <li><code>zipcode STARTS WITH "100"</code></li>
                                            <li><code>phone STARTS WITH "+1-212"</code></li>
                                            <li>Hierarchical codes, phone numbers, SKUs</li>
                                        </ul>
                                        <div class="alert alert-info small mb-0 mt-2">
                                            <i class="fas fa-info-circle me-1"></i>
                                            Uses Trie (prefix tree) data structure for efficient prefix lookups.
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- TRIGRAM Deep Dive Section -->
                        <div class="card border-warning mb-4 mt-3">
                            <div class="card-header bg-warning text-dark">
                                <h5 class="mb-0"><i class="fas fa-search me-2"></i>TRIGRAM Index Deep Dive - Accelerating Regex Searches</h5>
                            </div>
                            <div class="card-body">
                                <p>
                                    The TRIGRAM index is the most powerful index type for <strong>pattern-based searches</strong> on JSON attributes.
                                    It can turn expensive O(n) regex scans into fast O(candidates) lookups.
                                </p>
                                
                                <h6 class="mt-3"><i class="fas fa-cogs me-2 text-secondary"></i>How Trigram Indexing Works</h6>
                                <pre class="bg-dark text-light p-3 rounded"><code># Example: Indexing "john@gmail.com"

Step 1: Generate Trigrams (3-character sequences)
┌───────────────────────────────────────────────────────────────────┐
│ "john@gmail.com" → [joh, ohn, hn@, n@g, @gm, gma, mai, ail,      │
│                     il., l.c, .co, com]                           │
└───────────────────────────────────────────────────────────────────┘

Step 2: Build Inverted Index
┌─────────────────────────────────────────────────────────────────┐
│ Trigram Index:                                                   │
│   "@gm" → [customer_001, customer_045, customer_089]            │
│   "gma" → [customer_001, customer_045, customer_089]            │
│   "mai" → [customer_001, customer_023, customer_045, ...]       │
│   "com" → [customer_001, customer_002, customer_003, ...]       │
└─────────────────────────────────────────────────────────────────┘</code></pre>
                                
                                <h6 class="mt-4"><i class="fas fa-bolt me-2 text-warning"></i>Regex Query Acceleration</h6>
                                <pre class="bg-dark text-light p-3 rounded"><code># Query: email MATCHES ".*@gmail\.com$"

Step 1: Extract Literals from Regex
┌───────────────────────────────────────────────────────────────────┐
│ Regex: ".*@gmail\.com$"                                          │
│ Literals Found: ["@gmail", ".com"]                               │
│ Best Literal: "@gmail" (longest, most selective)                 │
└───────────────────────────────────────────────────────────────────┘

Step 2: Generate Trigrams from Literal
┌───────────────────────────────────────────────────────────────────┐
│ "@gmail" → [@gm, gma, mai, ail]                                  │
└───────────────────────────────────────────────────────────────────┘

Step 3: Intersect Posting Lists
┌───────────────────────────────────────────────────────────────────┐
│ "@gm" candidates: [001, 045, 089]                                │
│ "gma" candidates: [001, 045, 089]                                │
│ "mai" candidates: [001, 023, 045, 089, 156]                      │
│ "ail" candidates: [001, 045, 089, 234]                           │
│                                                                   │
│ INTERSECTION: [001, 045, 089] ← Only 3 candidates from 100K!    │
└───────────────────────────────────────────────────────────────────┘

Step 4: Verify with Full Regex (only 3 documents!)
┌───────────────────────────────────────────────────────────────────┐
│ Load customer_001 → email="john@gmail.com"    → ✓ MATCH         │
│ Load customer_045 → email="jane@gmail.com"    → ✓ MATCH         │
│ Load customer_089 → email="bob@gmail.com"     → ✓ MATCH         │
└───────────────────────────────────────────────────────────────────┘

Result: 3 matches in ~5ms (vs 8,450ms full scan on 100K documents)</code></pre>
                                
                                <h6 class="mt-4"><i class="fas fa-code me-2 text-primary"></i>Supported Query Operations</h6>
                                <table class="table table-sm table-bordered">
                                    <thead class="table-dark">
                                        <tr>
                                            <th>Operation</th>
                                            <th>Query Syntax</th>
                                            <th>Example</th>
                                            <th>Index Usage</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td><strong>Regex</strong></td>
                                            <td><code>{"field": {"regex": "pattern"}}</code></td>
                                            <td><code>{"email": {"regex": ".*@gmail\\.com$"}}</code></td>
                                            <td class="table-success">✓ TRIGRAM accelerated</td>
                                        </tr>
                                        <tr>
                                            <td><strong>Contains</strong></td>
                                            <td><code>{"field": {"contains": "substring"}}</code></td>
                                            <td><code>{"name": {"contains": "smith"}}</code></td>
                                            <td class="table-success">✓ TRIGRAM accelerated</td>
                                        </tr>
                                        <tr>
                                            <td><strong>Prefix</strong></td>
                                            <td><code>{"field": {"prefix": "value"}}</code></td>
                                            <td><code>{"sku": {"prefix": "NYC-"}}</code></td>
                                            <td class="table-success">✓ TRIGRAM/PREFIX accelerated</td>
                                        </tr>
                                        <tr>
                                            <td><strong>Starts With</strong></td>
                                            <td><code>{"field": {"startswith": "value"}}</code></td>
                                            <td><code>{"phone": {"startswith": "+1-212"}}</code></td>
                                            <td class="table-success">✓ TRIGRAM/PREFIX accelerated</td>
                                        </tr>
                                    </tbody>
                                </table>
                                
                                <h6 class="mt-4"><i class="fas fa-exclamation-triangle me-2 text-danger"></i>When Trigram Index Falls Back to Full Scan</h6>
                                <ul class="small">
                                    <li><strong>No literals in regex:</strong> <code>.*</code>, <code>.+</code>, <code>[a-z]+</code> - no extractable text</li>
                                    <li><strong>Literals too short:</strong> <code>.*@.*</code> - "@" is only 1 character (need 3+ for trigrams)</li>
                                    <li><strong>Only character classes:</strong> <code>\\d{4}-\\d{2}-\\d{2}</code> - no literal strings</li>
                                </ul>
                                <div class="alert alert-info small">
                                    <i class="fas fa-lightbulb me-2"></i>
                                    <strong>Tip:</strong> Design regex patterns with at least 3+ character literals for best index usage.
                                    <code>".*@gmail\\.com$"</code> is excellent (has "@gmail" and ".com").
                                    <code>".*@.+\\.com$"</code> is poor (only ".com" is usable).
                                </div>
                            </div>
                        </div>
                        
                        <!-- Configuration -->
                        <h5 class="mt-4"><i class="fas fa-cog me-2 text-warning"></i>Configuration</h5>
                        <p>Indexes are defined in <code>${kuber.base.datadir}/index.yaml</code> (default: <code>./data/index.yaml</code>):</p>
                        
                        <div class="alert alert-success">
                            <i class="fas fa-magic me-2"></i>
                            <strong>Auto-Save:</strong> When you create or delete indexes via the Admin UI or REST API, 
                            the <code>index.yaml</code> file is automatically updated. Changes persist across server restarts.
                        </div>
                        
                        <pre class="bg-dark text-light p-3 rounded"><code># ${kuber.base.datadir}/index.yaml
# Auto-managed by Kuber. Manual edits are also supported.

indexing:
  enabled: true
  storage: hybrid           # memory, rocksdb, or hybrid
  rebuild-on-startup: true  # Rebuild indexes from data on startup
  rebuild-threads: 4        # Parallel threads for rebuild
  max-memory-per-region-mb: 256
  max-indexes-per-region: 20
  persistence:
    enabled: true
    sync-interval-seconds: 30

regions:
  customers:
    indexes:
      - field: status
        type: hash
        description: "Customer status for filtering"
      
      - field: city
        type: hash
        description: "City for geographic queries"
      
      - field: age
        type: btree
        description: "Age for demographic range queries"
      
      - field: created_at
        type: btree
        description: "Creation date for time-based queries"
      
      - field: email
        type: trigram             # NEW: For regex/pattern searches
        description: "Email for pattern matching (e.g., .*@gmail.com)"
      
      - field: name
        type: trigram             # NEW: For contains/substring searches  
        description: "Name for substring searches"
      
      - field: sku
        type: prefix              # NEW: For prefix/starts-with searches
        description: "SKU codes for prefix matching"
      
      - field: status,city    # Composite index
        type: hash
        description: "Combined status+city for common pattern"
  
  orders:
    indexes:
      - field: status
        type: hash
      - field: customer_id
        type: hash
      - field: amount
        type: btree
      - field: order_date
        type: btree
      - field: tracking_number
        type: trigram             # For tracking number pattern searches
      - field: region_code
        type: prefix              # For region hierarchy queries</code></pre>
                        
                        <!-- Application Properties -->
                        <h5 class="mt-4"><i class="fas fa-file-alt me-2 text-secondary"></i>Application Properties</h5>
                        <pre class="bg-dark text-light p-3 rounded"><code># application.properties

# Index configuration file location (default: ${kuber.base.datadir}/index.yaml)
# kuber.indexing.config-file=/custom/path/index.yaml

# Watch for manual file changes and hot-reload (default: true)
kuber.indexing.watch-for-changes=true

# Auto-save configuration when indexes are created/deleted via API (default: true)
kuber.indexing.auto-save=true</code></pre>
                        
                        <!-- REST API -->
                        <h5 class="mt-4"><i class="fas fa-code me-2 text-primary"></i>REST API</h5>
                        
                        <table class="table table-bordered table-sm">
                            <thead class="table-dark">
                                <tr>
                                    <th>Method</th>
                                    <th>Endpoint</th>
                                    <th>Description</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><span class="badge bg-success">GET</span></td>
                                    <td><code>/api/admin/indexes</code></td>
                                    <td>List all indexes</td>
                                </tr>
                                <tr>
                                    <td><span class="badge bg-success">GET</span></td>
                                    <td><code>/api/admin/indexes/stats</code></td>
                                    <td>Global index statistics</td>
                                </tr>
                                <tr>
                                    <td><span class="badge bg-success">GET</span></td>
                                    <td><code>/api/admin/indexes/{region}</code></td>
                                    <td>List indexes for region</td>
                                </tr>
                                <tr>
                                    <td><span class="badge bg-primary">POST</span></td>
                                    <td><code>/api/admin/indexes/{region}</code></td>
                                    <td>Create new index</td>
                                </tr>
                                <tr>
                                    <td><span class="badge bg-danger">DELETE</span></td>
                                    <td><code>/api/admin/indexes/{region}/{field}</code></td>
                                    <td>Drop an index</td>
                                </tr>
                                <tr>
                                    <td><span class="badge bg-primary">POST</span></td>
                                    <td><code>/api/admin/indexes/{region}/{field}/rebuild</code></td>
                                    <td>Rebuild specific index</td>
                                </tr>
                                <tr>
                                    <td><span class="badge bg-primary">POST</span></td>
                                    <td><code>/api/admin/indexes/{region}/rebuild</code></td>
                                    <td>Rebuild all region indexes</td>
                                </tr>
                                <tr>
                                    <td><span class="badge bg-primary">POST</span></td>
                                    <td><code>/api/admin/indexes/rebuild-all</code></td>
                                    <td>Rebuild all indexes</td>
                                </tr>
                                <tr>
                                    <td><span class="badge bg-success">GET</span></td>
                                    <td><code>/api/admin/indexes/{region}/{field}/stats</code></td>
                                    <td>Index statistics</td>
                                </tr>
                                <tr>
                                    <td><span class="badge bg-primary">POST</span></td>
                                    <td><code>/api/admin/indexes/reload-config</code></td>
                                    <td>Reload index.yaml configuration</td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <!-- API Examples -->
                        <h6 class="mt-3">Create Index Example</h6>
                        <pre class="bg-dark text-light p-3 rounded"><code>POST /api/admin/indexes/customers
Content-Type: application/json

{
  "field": "email",
  "type": "hash",
  "description": "Email for customer lookup",
  "rebuildNow": true
}

Response:
{
  "success": true,
  "message": "Index created successfully",
  "region": "customers",
  "field": "email",
  "type": "HASH"
}</code></pre>
                        
                        <h6 class="mt-3">Rebuild Index Example</h6>
                        <pre class="bg-dark text-light p-3 rounded"><code>POST /api/admin/indexes/customers/email/rebuild

Response:
{
  "success": true,
  "message": "Index rebuilt successfully",
  "region": "customers",
  "field": "email",
  "entries": 45000,
  "rebuildTimeMs": 1250
}</code></pre>
                        
                        <!-- Client Code Examples for Trigram Searches -->
                        <div class="card border-warning mt-4 mb-4">
                            <div class="card-header bg-warning text-dark">
                                <h5 class="mb-0"><i class="fas fa-code me-2"></i>Client Code Examples - Using TRIGRAM Index</h5>
                            </div>
                            <div class="card-body">
                                <p>
                                    Once you've created a TRIGRAM index on a field, your regex/contains/prefix searches are 
                                    <strong>automatically accelerated</strong>. No code changes needed - just use the standard search APIs.
                                </p>
                                
                                <h6 class="mt-3"><i class="fas fa-database me-2 text-secondary"></i>Step 1: Create TRIGRAM Index</h6>
                                <ul class="nav nav-tabs" role="tablist">
                                    <li class="nav-item"><a class="nav-link active" data-bs-toggle="tab" href="#create-yaml">YAML Config</a></li>
                                    <li class="nav-item"><a class="nav-link" data-bs-toggle="tab" href="#create-rest">REST API</a></li>
                                    <li class="nav-item"><a class="nav-link" data-bs-toggle="tab" href="#create-ui">Admin UI</a></li>
                                </ul>
                                <div class="tab-content mt-2">
                                    <div class="tab-pane fade show active" id="create-yaml">
<pre class="bg-dark text-light p-3 rounded"><code># data/index.yaml - Add TRIGRAM index for email field
regions:
  customers:
    indexes:
      - field: email
        type: trigram
        description: "Email patterns - regex, contains, domain matching"
      
      - field: name
        type: trigram
        description: "Name substring searches"
      
      - field: description
        type: trigram
        description: "Product description full-text patterns"</code></pre>
                                    </div>
                                    <div class="tab-pane fade" id="create-rest">
<pre class="bg-dark text-light p-3 rounded"><code># Create TRIGRAM index via REST API
curl -X POST http://localhost:7070/api/admin/indexes/customers \
  -H "Content-Type: application/json" \
  -H "X-API-Key: kub_xxx" \
  -d '{
    "field": "email",
    "type": "trigram",
    "description": "Email for regex pattern searches",
    "rebuildNow": true
  }'</code></pre>
                                    </div>
                                    <div class="tab-pane fade" id="create-ui">
                                        <p class="mt-2">Navigate to <a href="/admin/indexes/create"><strong>/admin/indexes/create</strong></a> and:</p>
                                        <ol class="small">
                                            <li>Select region: <code>customers</code></li>
                                            <li>Enter field path: <code>email</code></li>
                                            <li>Select type: <code>TRIGRAM</code></li>
                                            <li>Click "Create Index"</li>
                                        </ol>
                                    </div>
                                </div>
                                
                                <h6 class="mt-4"><i class="fas fa-search me-2 text-primary"></i>Step 2: Search with Regex/Contains (Automatically Uses Index)</h6>
                                <ul class="nav nav-tabs" role="tablist">
                                    <li class="nav-item"><a class="nav-link active" data-bs-toggle="tab" href="#search-python">Python</a></li>
                                    <li class="nav-item"><a class="nav-link" data-bs-toggle="tab" href="#search-java">Java</a></li>
                                    <li class="nav-item"><a class="nav-link" data-bs-toggle="tab" href="#search-csharp">C#</a></li>
                                    <li class="nav-item"><a class="nav-link" data-bs-toggle="tab" href="#search-rest">REST API</a></li>
                                </ul>
                                <div class="tab-content mt-2">
                                    <div class="tab-pane fade show active" id="search-python">
<pre class="bg-dark text-light p-3 rounded"><code>from kuber import KuberRestClient

client = KuberRestClient('localhost', 7070, api_key='kub_xxx')
client.select_region('customers')

# ═══════════════════════════════════════════════════════════════════
# REGEX SEARCH - Uses TRIGRAM index automatically!
# ═══════════════════════════════════════════════════════════════════

# Find all Gmail users (extracts "@gmail" and ".com" trigrams)
results = client.generic_search({
    "region": "customers",
    "type": "json",
    "attributes": {
        "email": {"regex": ".*@gmail\\.com$"}
    },
    "limit": 1000
})
print(f"Gmail users: {len(results)}")

# Find emails from specific domains (OR pattern)
results = client.generic_search({
    "region": "customers",
    "type": "json", 
    "attributes": {
        "email": {"regex": ".*@(gmail|yahoo|outlook)\\.com$"}
    }
})

# ═══════════════════════════════════════════════════════════════════
# CONTAINS SEARCH - Substring matching via TRIGRAM
# ═══════════════════════════════════════════════════════════════════

# Find customers with "smith" anywhere in name
results = client.generic_search({
    "region": "customers",
    "type": "json",
    "attributes": {
        "name": {"contains": "smith"}
    }
})
print(f"Customers with 'smith' in name: {len(results)}")

# ═══════════════════════════════════════════════════════════════════
# PREFIX/STARTS-WITH SEARCH
# ═══════════════════════════════════════════════════════════════════

# Find emails starting with "john"
results = client.generic_search({
    "region": "customers",
    "type": "json",
    "attributes": {
        "email": {"prefix": "john"}
    }
})

# Alternative syntax
results = client.generic_search({
    "region": "customers",
    "type": "json",
    "attributes": {
        "email": {"startswith": "admin@"}
    }
})

# ═══════════════════════════════════════════════════════════════════
# COMBINE TRIGRAM WITH OTHER INDEXES
# ═══════════════════════════════════════════════════════════════════

# Gmail users in NYC who are active (uses HASH + TRIGRAM indexes)
results = client.generic_search({
    "region": "customers",
    "type": "json",
    "attributes": {
        "email": {"regex": ".*@gmail\\.com$"},  # TRIGRAM index
        "city": "NYC",                           # HASH index
        "status": "active"                       # HASH index
    }
})</code></pre>
                                    </div>
                                    <div class="tab-pane fade" id="search-java">
<pre class="bg-dark text-light p-3 rounded"><code>import com.kuber.client.KuberRestClient;
import java.util.*;

KuberRestClient client = new KuberRestClient("localhost", 7070, "kub_xxx");
client.selectRegion("customers");

// ═══════════════════════════════════════════════════════════════════
// REGEX SEARCH - Uses TRIGRAM index automatically!
// ═══════════════════════════════════════════════════════════════════

// Find all Gmail users
Map&lt;String, Object&gt; request = new HashMap&lt;&gt;();
request.put("region", "customers");
request.put("type", "json");
request.put("attributes", Map.of(
    "email", Map.of("regex", ".*@gmail\\.com$")
));
request.put("limit", 1000);

List&lt;Map&lt;String, Object&gt;&gt; results = client.genericSearch(request);
System.out.println("Gmail users: " + results.size());

// ═══════════════════════════════════════════════════════════════════
// CONTAINS SEARCH - Substring matching via TRIGRAM
// ═══════════════════════════════════════════════════════════════════

// Find customers with "smith" anywhere in name
request = new HashMap&lt;&gt;();
request.put("region", "customers");
request.put("type", "json");
request.put("attributes", Map.of(
    "name", Map.of("contains", "smith")
));

results = client.genericSearch(request);
System.out.println("Smiths: " + results.size());

// ═══════════════════════════════════════════════════════════════════
// PREFIX SEARCH
// ═══════════════════════════════════════════════════════════════════

// Find emails starting with "john"
request = new HashMap&lt;&gt;();
request.put("region", "customers");
request.put("type", "json");
request.put("attributes", Map.of(
    "email", Map.of("prefix", "john")
));

results = client.genericSearch(request);

// ═══════════════════════════════════════════════════════════════════
// COMBINE TRIGRAM WITH OTHER INDEXES
// ═══════════════════════════════════════════════════════════════════

// Gmail users in NYC who are active
request = new HashMap&lt;&gt;();
request.put("region", "customers");
request.put("type", "json");
request.put("attributes", Map.of(
    "email", Map.of("regex", ".*@gmail\\.com$"),  // TRIGRAM
    "city", "NYC",                                 // HASH
    "status", "active"                             // HASH
));

results = client.genericSearch(request);</code></pre>
                                    </div>
                                    <div class="tab-pane fade" id="search-csharp">
<pre class="bg-dark text-light p-3 rounded"><code>using Kuber.Client;

var client = new KuberRestClient("localhost", 7070, "kub_xxx");
client.SelectRegion("customers");

// ═══════════════════════════════════════════════════════════════════
// REGEX SEARCH - Uses TRIGRAM index automatically!
// ═══════════════════════════════════════════════════════════════════

// Find all Gmail users
var request = new Dictionary&lt;string, object&gt;
{
    ["region"] = "customers",
    ["type"] = "json",
    ["attributes"] = new Dictionary&lt;string, object&gt;
    {
        ["email"] = new Dictionary&lt;string, object&gt;
        {
            ["regex"] = @".*@gmail\.com$"
        }
    },
    ["limit"] = 1000
};

var results = await client.GenericSearchAsync(request);
Console.WriteLine($"Gmail users: {results.Count}");

// ═══════════════════════════════════════════════════════════════════
// CONTAINS SEARCH - Substring matching via TRIGRAM
// ═══════════════════════════════════════════════════════════════════

// Find customers with "smith" anywhere in name
request = new Dictionary&lt;string, object&gt;
{
    ["region"] = "customers",
    ["type"] = "json",
    ["attributes"] = new Dictionary&lt;string, object&gt;
    {
        ["name"] = new Dictionary&lt;string, object&gt;
        {
            ["contains"] = "smith"
        }
    }
};

results = await client.GenericSearchAsync(request);
Console.WriteLine($"Smiths: {results.Count}");

// ═══════════════════════════════════════════════════════════════════
// COMBINE TRIGRAM WITH OTHER INDEXES  
// ═══════════════════════════════════════════════════════════════════

// Gmail users in NYC who are active
request = new Dictionary&lt;string, object&gt;
{
    ["region"] = "customers",
    ["type"] = "json",
    ["attributes"] = new Dictionary&lt;string, object&gt;
    {
        ["email"] = new Dictionary&lt;string, object&gt; { ["regex"] = @".*@gmail\.com$" },
        ["city"] = "NYC",
        ["status"] = "active"
    }
};

results = await client.GenericSearchAsync(request);</code></pre>
                                    </div>
                                    <div class="tab-pane fade" id="search-rest">
<pre class="bg-dark text-light p-3 rounded"><code># ═══════════════════════════════════════════════════════════════════
# REGEX SEARCH via REST API
# ═══════════════════════════════════════════════════════════════════

# Find all Gmail users
curl -X POST http://localhost:7070/api/v1/genericsearch \
  -H "Content-Type: application/json" \
  -H "X-API-Key: kub_xxx" \
  -d '{
    "region": "customers",
    "type": "json",
    "attributes": {
      "email": {"regex": ".*@gmail\\.com$"}
    },
    "limit": 1000
  }'

# ═══════════════════════════════════════════════════════════════════
# CONTAINS SEARCH via REST API
# ═══════════════════════════════════════════════════════════════════

curl -X POST http://localhost:7070/api/v1/genericsearch \
  -H "Content-Type: application/json" \
  -H "X-API-Key: kub_xxx" \
  -d '{
    "region": "customers",
    "type": "json",
    "attributes": {
      "name": {"contains": "smith"}
    }
  }'

# ═══════════════════════════════════════════════════════════════════
# PREFIX SEARCH via REST API  
# ═══════════════════════════════════════════════════════════════════

curl -X POST http://localhost:7070/api/v1/genericsearch \
  -H "Content-Type: application/json" \
  -H "X-API-Key: kub_xxx" \
  -d '{
    "region": "customers",
    "type": "json",
    "attributes": {
      "email": {"prefix": "john"}
    }
  }'

# ═══════════════════════════════════════════════════════════════════
# COMBINED SEARCH (Multiple Index Types)
# ═══════════════════════════════════════════════════════════════════

curl -X POST http://localhost:7070/api/v1/genericsearch \
  -H "Content-Type: application/json" \
  -H "X-API-Key: kub_xxx" \
  -d '{
    "region": "customers",
    "type": "json",
    "attributes": {
      "email": {"regex": ".*@gmail\\.com$"},
      "city": "NYC",
      "status": "active",
      "age": {"gte": 25, "lte": 50}
    },
    "fields": ["name", "email", "city"],
    "limit": 100
  }'</code></pre>
                                    </div>
                                </div>
                                
                                <h6 class="mt-4"><i class="fas fa-chart-line me-2 text-success"></i>Step 3: Verify Index Usage</h6>
                                <p class="small">Check if your queries are using the TRIGRAM index via the Admin UI or API:</p>
<pre class="bg-dark text-light p-3 rounded"><code># Get TRIGRAM index statistics
curl http://localhost:7070/api/admin/indexes/customers/email/stats \
  -H "X-API-Key: kub_xxx"

# Response shows acceleration metrics:
{
  "field": "email",
  "type": "TRIGRAM",
  "entries": 100000,
  "uniqueValues": 98500,
  "uniqueTrigrams": 2450,
  "memoryBytes": 15234567,
  "supportsRegexQueries": true,
  "supportsPrefixQueries": true,
  "supportsContainsQueries": true,
  "regexQueriesAccelerated": 1523,   ← Queries that used trigram lookup
  "regexQueriesFullScan": 12,        ← Queries that fell back to scan
  "accelerationRate": "99.2%",       ← Success rate
  "topTrigrams": [
    {"trigram": "com", "count": 98000},
    {"trigram": ".co", "count": 98000},
    {"trigram": "mai", "count": 45000}
  ]
}</code></pre>
                                
                                <div class="alert alert-success mt-3 small">
                                    <i class="fas fa-magic me-2"></i>
                                    <strong>Zero Code Changes Required!</strong> Once you create a TRIGRAM index, 
                                    all existing regex/contains/prefix queries automatically benefit from index acceleration.
                                    The query optimizer detects the index and uses it transparently.
                                </div>
                            </div>
                        </div>
                        
                        <!-- Redis Protocol -->
                        <h5 class="mt-4"><i class="fas fa-terminal me-2 text-danger"></i>Redis Protocol Commands</h5>
                        <pre class="bg-dark text-light p-3 rounded"><code># Create hash index
JINDEX CREATE customers status HASH

# Create btree index
JINDEX CREATE customers age BTREE

# Create composite index
JINDEX CREATE customers status,city HASH

# Drop index
JINDEX DROP customers status

# List indexes
JINDEX LIST customers

# Get index statistics
JINDEX STATS customers status

# Rebuild index
JINDEX REBUILD customers status

# Rebuild all indexes for region
JINDEX REBUILDALL customers</code></pre>
                        
                        <!-- Query Optimization -->
                        <h5 class="mt-4"><i class="fas fa-magic me-2 text-purple"></i>Query Optimization</h5>
                        <p>The query optimizer automatically selects the best index strategy:</p>
                        
                        <div class="card bg-light mb-3">
                            <div class="card-body">
                                <h6>Query: <code>status = "active" AND city = "NYC"</code></h6>
                                <ol class="small mb-0">
                                    <li>Check available indexes: status (HASH), city (HASH) ✓</li>
                                    <li>Lookup status index → 32,000 keys</li>
                                    <li>Lookup city index → 5,000 keys</li>
                                    <li>Intersect sets (smaller first) → 450 matching keys</li>
                                    <li>Fetch only 450 documents from cache</li>
                                    <li><strong>Result:</strong> 450 matches in 12ms (vs 8,450ms without indexes)</li>
                                </ol>
                            </div>
                        </div>
                        
                        <!-- Best Practices -->
                        <h5 class="mt-4"><i class="fas fa-check-circle me-2 text-success"></i>Best Practices</h5>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="card border-success mb-3">
                                    <div class="card-header bg-success text-white">
                                        <i class="fas fa-thumbs-up me-2"></i>DO
                                    </div>
                                    <ul class="list-group list-group-flush small">
                                        <li class="list-group-item">Use HASH for low-cardinality fields (status, type, category)</li>
                                        <li class="list-group-item">Use BTREE for numeric/date range queries</li>
                                        <li class="list-group-item">Use <strong>TRIGRAM for regex/contains searches</strong> on text fields</li>
                                        <li class="list-group-item">Use <strong>PREFIX for starts-with queries</strong> (SKUs, codes, phone numbers)</li>
                                        <li class="list-group-item">Design regex with 3+ character literals for TRIGRAM acceleration</li>
                                        <li class="list-group-item">Create composite indexes for frequently combined fields</li>
                                        <li class="list-group-item">Monitor index memory usage and hit rates</li>
                                        <li class="list-group-item">Limit to 5-10 indexes per region</li>
                                    </ul>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="card border-danger mb-3">
                                    <div class="card-header bg-danger text-white">
                                        <i class="fas fa-thumbs-down me-2"></i>DON'T
                                    </div>
                                    <ul class="list-group list-group-flush small">
                                        <li class="list-group-item">Don't index high-cardinality fields (UUID, email) with HASH</li>
                                        <li class="list-group-item">Don't use TRIGRAM on very short fields (&lt;3 chars)</li>
                                        <li class="list-group-item">Don't expect TRIGRAM to accelerate regex without literals (e.g., <code>.*</code>, <code>.+</code>)</li>
                                        <li class="list-group-item">Don't create indexes on rarely queried fields</li>
                                        <li class="list-group-item">Don't over-index - each index adds write overhead</li>
                                        <li class="list-group-item">Don't ignore memory limits (TRIGRAM uses more memory)</li>
                                        <li class="list-group-item">Don't index array fields (not supported)</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Memory Considerations -->
                        <h5 class="mt-4"><i class="fas fa-memory me-2 text-info"></i>Memory Considerations</h5>
                        <table class="table table-bordered table-sm">
                            <thead class="table-light">
                                <tr>
                                    <th>Index Type</th>
                                    <th>Memory per Document</th>
                                    <th>100K Documents</th>
                                    <th>Notes</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>HASH (low cardinality)</td>
                                    <td>~50 bytes</td>
                                    <td>~5 MB</td>
                                    <td>Best for enum-like fields</td>
                                </tr>
                                <tr>
                                    <td>HASH (high cardinality)</td>
                                    <td>~80 bytes</td>
                                    <td>~8 MB</td>
                                    <td>Many unique values</td>
                                </tr>
                                <tr>
                                    <td>BTREE</td>
                                    <td>~100 bytes</td>
                                    <td>~10 MB</td>
                                    <td>Range queries on numbers/dates</td>
                                </tr>
                                <tr class="table-warning">
                                    <td>TRIGRAM</td>
                                    <td>~150-300 bytes</td>
                                    <td>~15-30 MB</td>
                                    <td>Depends on value length; enables regex/contains</td>
                                </tr>
                                <tr class="table-info">
                                    <td>PREFIX</td>
                                    <td>~80 bytes</td>
                                    <td>~8 MB</td>
                                    <td>Trie structure; efficient for hierarchical data</td>
                                </tr>
                                <tr>
                                    <td>COMPOSITE (2 fields)</td>
                                    <td>~120 bytes</td>
                                    <td>~12 MB</td>
                                    <td>Combines two HASH indexes</td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <!-- Off-Heap Storage -->
                        <h5 class="mt-4"><i class="fas fa-hdd me-2 text-warning"></i>Off-Heap Storage <span class="badge bg-success">NEW in 2.2.0</span></h5>
                        <p>
                            For large indexes or memory-constrained environments, Kuber supports <strong>off-heap storage</strong> 
                            that stores index data in direct memory (outside the JVM heap). This provides:
                        </p>
                        <div class="row mb-3">
                            <div class="col-md-6">
                                <div class="card border-success">
                                    <div class="card-header bg-success text-white">
                                        <i class="fas fa-check me-2"></i>Benefits
                                    </div>
                                    <ul class="list-group list-group-flush">
                                        <li class="list-group-item"><strong>Zero GC pressure</strong> - No heap usage for index data</li>
                                        <li class="list-group-item"><strong>Predictable latency</strong> - No GC pauses affecting queries</li>
                                        <li class="list-group-item"><strong>5-10x more scalable</strong> - Limited by RAM, not heap</li>
                                        <li class="list-group-item"><strong>Better for large indexes</strong> - Recommended for >10M entries</li>
                                    </ul>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="card border-warning">
                                    <div class="card-header bg-warning text-dark">
                                        <i class="fas fa-exclamation-triangle me-2"></i>Trade-offs
                                    </div>
                                    <ul class="list-group list-group-flush">
                                        <li class="list-group-item">~5-20x slower individual lookups</li>
                                        <li class="list-group-item">Still 100-1000x faster than full scans</li>
                                        <li class="list-group-item">Slightly higher memory overhead</li>
                                        <li class="list-group-item">Requires direct memory allocation</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                        
                        <h6><i class="fas fa-tachometer-alt me-2"></i>Performance Comparison</h6>
                        <table class="table table-bordered table-sm">
                            <thead class="table-dark">
                                <tr>
                                    <th>Index Type</th>
                                    <th>On-Heap</th>
                                    <th>Off-Heap</th>
                                    <th>Slowdown</th>
                                    <th>Still vs Full Scan</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>HASH lookup</td>
                                    <td>~50-100 ns</td>
                                    <td>~500-2,000 ns</td>
                                    <td>5-20x</td>
                                    <td class="table-success"><strong>1,000x faster</strong></td>
                                </tr>
                                <tr>
                                    <td>BTREE lookup</td>
                                    <td>~200-500 ns</td>
                                    <td>~2,000-5,000 ns</td>
                                    <td>5-10x</td>
                                    <td class="table-success"><strong>200x faster</strong></td>
                                </tr>
                                <tr>
                                    <td>TRIGRAM search</td>
                                    <td>~1-5 ms</td>
                                    <td>~5-20 ms</td>
                                    <td>3-5x</td>
                                    <td class="table-success"><strong>100x faster</strong></td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <h6 class="mt-3"><i class="fas fa-cog me-2"></i>Configuration</h6>
                        <pre class="bg-light p-3 rounded"><code># Default storage mode for all indexes (HEAP or OFFHEAP)
kuber.indexing.default-storage=HEAP

# Per-type storage overrides (HEAP, OFFHEAP, or DEFAULT)
kuber.indexing.hash-storage=DEFAULT
kuber.indexing.btree-storage=DEFAULT
kuber.indexing.trigram-storage=OFFHEAP    # Recommended for memory-hungry TRIGRAM
kuber.indexing.prefix-storage=DEFAULT

# Off-heap buffer sizes
kuber.indexing.offheap-initial-size=16777216   # 16MB initial
kuber.indexing.offheap-max-size=1073741824     # 1GB max per index</code></pre>
                        
                        <div class="alert alert-info">
                            <i class="fas fa-lightbulb me-2"></i>
                            <strong>Recommendation:</strong> Use OFFHEAP for TRIGRAM indexes by default, as they consume 
                            significantly more memory than other index types. For indexes with >10M entries, consider 
                            switching all index types to OFFHEAP to avoid GC pressure.
                        </div>
                        
                        <!-- Admin UI -->
                        <h5 class="mt-4"><i class="fas fa-desktop me-2 text-primary"></i>Admin UI</h5>
                        <p>Access the index management dashboard at <a href="/admin/indexes" class="fw-bold">/admin/indexes</a>:</p>
                        <ul>
                            <li>View all indexes across regions with statistics</li>
                            <li><a href="/admin/indexes/create">Create new indexes</a> with field selection and type guide</li>
                            <li>Drop existing indexes with confirmation</li>
                            <li>Rebuild indexes on demand (single, per-region, or all)</li>
                            <li>Monitor memory usage and hit rates</li>
                            <li>View index statistics and value distribution</li>
                            <li><strong>NEW:</strong> Access region-specific index pages from the <a href="/regions">Regions</a> page</li>
                            <li><strong>NEW:</strong> Standalone statistics pages with detailed distribution charts</li>
                        </ul>
                        <div class="alert alert-info">
                            <i class="fas fa-lightbulb me-2"></i>
                            <strong>Tip:</strong> The <a href="/admin/indexes/create">Create Index page</a> includes 
                            comprehensive guides on choosing the right index type, field path syntax, and performance tips.
                        </div>
                        
                        <!-- File-Based Index Operations -->
                        <h5 class="mt-4"><i class="fas fa-file-alt me-2 text-success"></i>File-Based Index Operations <span class="badge bg-success">NEW in 2.2.0</span></h5>
                        <p>
                            Similar to the <code>kuber.shutdown</code> mechanism, you can trigger index operations by creating 
                            special files in the Kuber working directory. This is ideal for <strong>automation, scripting, 
                            and CI/CD pipelines</strong> without requiring API calls or web UI access.
                        </p>
                        
                        <div class="alert alert-success">
                            <i class="fas fa-magic me-2"></i>
                            <strong>How it works:</strong> Kuber watches for trigger files every 5 seconds (configurable). 
                            When a matching file is detected, the operation executes and the file is automatically deleted.
                        </div>
                        
                        <h6 class="mt-3"><i class="fas fa-list me-2"></i>Supported Trigger Files</h6>
                        <table class="table table-bordered table-sm">
                            <thead class="table-dark">
                                <tr>
                                    <th>File Name Pattern</th>
                                    <th>Action</th>
                                    <th>Example</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code>kuber.index.&lt;region&gt;.rebuild</code></td>
                                    <td>Rebuild all indexes for a region</td>
                                    <td><code>kuber.index.customers.rebuild</code></td>
                                </tr>
                                <tr>
                                    <td><code>kuber.index.&lt;region&gt;.drop</code></td>
                                    <td>Drop all indexes for a region</td>
                                    <td><code>kuber.index.orders.drop</code></td>
                                </tr>
                                <tr>
                                    <td><code>kuber.index.&lt;region&gt;.&lt;field&gt;.rebuild</code></td>
                                    <td>Rebuild a specific index</td>
                                    <td><code>kuber.index.customers.email.rebuild</code></td>
                                </tr>
                                <tr>
                                    <td><code>kuber.index.&lt;region&gt;.&lt;field&gt;.drop</code></td>
                                    <td>Drop a specific index</td>
                                    <td><code>kuber.index.products.sku.drop</code></td>
                                </tr>
                                <tr class="table-info">
                                    <td><code>kuber.index.all.rebuild</code></td>
                                    <td>Rebuild ALL indexes across all regions</td>
                                    <td><code>kuber.index.all.rebuild</code></td>
                                </tr>
                                <tr class="table-success">
                                    <td><code>kuber.index.&lt;region&gt;.&lt;field&gt;.create.&lt;type&gt;</code></td>
                                    <td>Create a new index</td>
                                    <td><code>kuber.index.users.city.create.hash</code></td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <h6 class="mt-3"><i class="fas fa-plus-circle me-2"></i>Index Types for Creation</h6>
                        <p>When creating indexes via file triggers, use these type suffixes:</p>
                        <div class="d-flex flex-wrap gap-2 mb-3">
                            <span class="badge bg-primary fs-6">.create.hash</span>
                            <span class="badge bg-success fs-6">.create.btree</span>
                            <span class="badge bg-warning text-dark fs-6">.create.trigram</span>
                            <span class="badge bg-info fs-6">.create.prefix</span>
                        </div>
                        
                        <h6 class="mt-3"><i class="fas fa-terminal me-2"></i>Usage Examples</h6>
                        <pre class="bg-dark text-light p-3 rounded"><code># Rebuild all indexes for 'customers' region after bulk data load
touch kuber.index.customers.rebuild

# Drop all indexes for 'temp_data' region before cleanup
touch kuber.index.temp_data.drop

# Rebuild a specific index after data corrections
touch kuber.index.orders.status.rebuild

# Drop an unused index to free memory
touch kuber.index.products.legacy_code.drop

# Rebuild ALL indexes (e.g., after major data migration)
touch kuber.index.all.rebuild

# Create new indexes via file triggers
touch kuber.index.customers.city.create.hash        # HASH for equality queries
touch kuber.index.orders.amount.create.btree        # BTREE for range queries
touch kuber.index.products.name.create.trigram      # TRIGRAM for regex/contains
touch kuber.index.inventory.sku.create.prefix       # PREFIX for starts-with</code></pre>
                        
                        <h6 class="mt-3"><i class="fas fa-cog me-2"></i>Configuration</h6>
                        <p>Configure file-based index operations in <code>application.properties</code>:</p>
                        <pre class="bg-light p-3 rounded"><code># Enable/disable file-based index triggers (default: true)
kuber.indexing.file-watcher-enabled=true

# Check interval in milliseconds (default: 5000 = 5 seconds)
kuber.indexing.file-watcher-interval-ms=5000

# Directory to watch for trigger files (default: current working directory)
kuber.indexing.file-watcher-directory=.</code></pre>
                        
                        <h6 class="mt-3"><i class="fas fa-project-diagram me-2"></i>Automation Workflow Example</h6>
                        <p>Combine with <a href="/help/autoload">Autoload</a> for complete data pipeline automation:</p>
                        <pre class="bg-dark text-light p-3 rounded"><code>#!/bin/bash
# data-pipeline.sh - Automated data load with index management

# Step 1: Load data via autoload
cp customers.csv data/autoload/inbox/
cp customers.csv.metadata data/autoload/inbox/

# Step 2: Wait for autoload to complete (check outbox)
while [ ! -f "data/autoload/outbox/customers.csv" ]; do
    sleep 5
done
echo "Data loaded successfully"

# Step 3: Create/rebuild indexes for the new data
touch kuber.index.customers.email.create.hash
touch kuber.index.customers.status.create.hash
touch kuber.index.customers.created_at.create.btree
touch kuber.index.customers.name.create.trigram

# Step 4: Wait for index operations to complete
sleep 10

echo "Pipeline complete: Data loaded and indexes created"</code></pre>
                        
                        <div class="row mt-3">
                            <div class="col-md-6">
                                <div class="card border-success">
                                    <div class="card-header bg-success text-white">
                                        <i class="fas fa-check me-2"></i>Best Use Cases
                                    </div>
                                    <ul class="list-group list-group-flush small">
                                        <li class="list-group-item">CI/CD pipeline automation</li>
                                        <li class="list-group-item">Scheduled batch processing scripts</li>
                                        <li class="list-group-item">Post-migration index rebuilds</li>
                                        <li class="list-group-item">Kubernetes init containers</li>
                                        <li class="list-group-item">Cron job maintenance tasks</li>
                                        <li class="list-group-item">Docker entrypoint scripts</li>
                                    </ul>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="card border-info">
                                    <div class="card-header bg-info text-white">
                                        <i class="fas fa-info-circle me-2"></i>Behavior Notes
                                    </div>
                                    <ul class="list-group list-group-flush small">
                                        <li class="list-group-item">Files are deleted after processing</li>
                                        <li class="list-group-item">Stale files cleaned on server startup</li>
                                        <li class="list-group-item">10-second grace period after startup</li>
                                        <li class="list-group-item">Operations logged with timing details</li>
                                        <li class="list-group-item">Multiple files processed in sorted order</li>
                                        <li class="list-group-item">Index config auto-saved after creation</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                        
                        <div class="alert alert-warning mt-3">
                            <i class="fas fa-exclamation-triangle me-2"></i>
                            <strong>Note:</strong> File names are case-sensitive. Region and field names must match exactly 
                            as they appear in your data. Use only alphanumeric characters, underscores, and hyphens in 
                            region/field names.
                        </div>
                        
                        <!-- Index Storage Options -->
                        <h5 class="mt-5"><i class="fas fa-database me-2 text-info"></i>Index Storage Options <span class="badge bg-success">v2.2.0</span></h5>
                        <p>Secondary indexes can be stored in different backends to balance between speed and memory usage:</p>
                        
                        <div class="alert alert-warning">
                            <i class="fas fa-exclamation-circle me-2"></i>
                            <strong>Index Storage vs Data Persistence:</strong>
                            <table class="table table-sm table-borderless mt-2 mb-0">
                                <tr>
                                    <td><code>kuber.persistence.type</code></td>
                                    <td>Where cache <strong>DATA</strong> is stored</td>
                                    <td><code>postgresql</code>, <code>mongodb</code>, <code>sqlite</code>, <code>rocksdb</code>, <code>lmdb</code>, <code>memory</code></td>
                                </tr>
                                <tr>
                                    <td><code>kuber.indexing.disk-backend</code></td>
                                    <td>Where <strong>INDEXES</strong> are stored</td>
                                    <td><code>rocksdb</code>, <code>lmdb</code>, <code>sqlite</code> (embedded DBs only)</td>
                                </tr>
                            </table>
                            <small class="text-muted">PostgreSQL/MongoDB are not available for index storage because indexes require fast local disk access. The Hybrid Query Strategy uses their native JSON query capabilities instead.</small>
                        </div>
                        
                        <table class="table table-bordered table-sm">
                            <thead class="table-dark">
                                <tr>
                                    <th>Storage</th>
                                    <th>Location</th>
                                    <th>Read</th>
                                    <th>Write</th>
                                    <th>RAM</th>
                                    <th>Persistent</th>
                                    <th>Best For</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr class="table-success">
                                    <td><strong>HEAP</strong></td>
                                    <td>JVM Heap</td>
                                    <td><span class="badge bg-success">Fastest</span></td>
                                    <td><span class="badge bg-success">Fastest</span></td>
                                    <td><span class="badge bg-danger">High</span></td>
                                    <td><i class="fas fa-times text-danger"></i></td>
                                    <td>Small indexes (&lt;10M)</td>
                                </tr>
                                <tr class="table-info">
                                    <td><strong>OFFHEAP</strong></td>
                                    <td>Direct Memory</td>
                                    <td><span class="badge bg-info">Fast</span></td>
                                    <td><span class="badge bg-info">Fast</span></td>
                                    <td><span class="badge bg-warning">Medium</span></td>
                                    <td><i class="fas fa-times text-danger"></i></td>
                                    <td>Large indexes, avoid GC</td>
                                </tr>
                                <tr class="table-warning">
                                    <td><strong>DISK (RocksDB)</strong></td>
                                    <td>Disk</td>
                                    <td><span class="badge bg-warning">Medium</span></td>
                                    <td><span class="badge bg-success">Fast</span></td>
                                    <td><span class="badge bg-success">Minimal</span></td>
                                    <td><i class="fas fa-check text-success"></i></td>
                                    <td>Write-heavy workloads</td>
                                </tr>
                                <tr class="table-warning">
                                    <td><strong>DISK (LMDB)</strong></td>
                                    <td>Disk</td>
                                    <td><span class="badge bg-success">Fast</span></td>
                                    <td><span class="badge bg-warning">Medium</span></td>
                                    <td><span class="badge bg-success">Minimal</span></td>
                                    <td><i class="fas fa-check text-success"></i></td>
                                    <td>Read-heavy workloads</td>
                                </tr>
                                <tr class="table-warning">
                                    <td><strong>DISK (SQLite)</strong></td>
                                    <td>Disk</td>
                                    <td><span class="badge bg-warning">Medium</span></td>
                                    <td><span class="badge bg-warning">Medium</span></td>
                                    <td><span class="badge bg-success">Minimal</span></td>
                                    <td><i class="fas fa-check text-success"></i></td>
                                    <td>Portable, debugging</td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <h6 class="mt-3">Disk Index Directory Structure</h6>
                        <pre class="bg-dark text-light p-3 rounded"><code># Configured via: kuber.indexing.disk-directory
./kuberdata/indexes/
├── rocksdb/      # If disk-backend=rocksdb
├── lmdb/         # If disk-backend=lmdb
└── sqlite/       # If disk-backend=sqlite</code></pre>
                        
                        <h6 class="mt-3">Configuration</h6>
                        <pre class="bg-dark text-light p-3 rounded"><code># Index storage mode: HEAP, OFFHEAP, or DISK
kuber.indexing.default-storage=HEAP

# Per-type overrides (TRIGRAM indexes use lots of memory!)
kuber.indexing.trigram-storage=OFFHEAP

# Disk backend: rocksdb, lmdb, or sqlite
kuber.indexing.disk-backend=rocksdb
kuber.indexing.disk-directory=${kuber.base.datadir}/indexes
kuber.indexing.disk-cache-size-mb=64
kuber.indexing.disk-bloom-filter-enabled=true
kuber.indexing.disk-reuse-on-startup=true</code></pre>
                        
                        <!-- Hybrid Query Strategy -->
                        <h5 class="mt-5"><i class="fas fa-random me-2 text-purple"></i>Hybrid Query Strategy <span class="badge bg-success">v2.2.0</span></h5>
                        <p>When no Kuber secondary index exists, the system can fall back to native database queries:</p>
                        
                        <pre class="bg-light p-3 rounded" style="font-family: monospace; font-size: 0.85rem;">
JSEARCH query arrives
        │
        ▼
┌───────────────────────────────────┐
│ 1. Check Kuber Secondary Index    │  ← O(1) hash or O(log n) btree
│    (HEAP / OFFHEAP / DISK)        │
└───────────────────────────────────┘
        │
   Index EXISTS?
   ├── YES → Return results (fastest)
   │
   └── NO ↓
        │
┌───────────────────────────────────┐
│ 2. Try Native Database Query      │  ← Uses DB's own indexes
│    PostgreSQL → GIN JSONB         │
│    MongoDB    → Native queries    │
│    SQLite     → JSON1 extension   │
└───────────────────────────────────┘
        │
   Supported?
   ├── YES → Return DB results (fast)
   │
   └── NO ↓
        │
┌───────────────────────────────────┐
│ 3. Full Scan Fallback             │  ← Parallel processing
│    (RocksDB, LMDB, Memory)        │
└───────────────────────────────────┘
</pre>
                        
                        <h6 class="mt-3">Native Query Support by Backend</h6>
                        <table class="table table-bordered table-sm">
                            <thead class="table-dark">
                                <tr>
                                    <th>Data Backend</th>
                                    <th>Native JSON Query</th>
                                    <th>Technology</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>PostgreSQL</td>
                                    <td><span class="badge bg-success">✓ Supported</span></td>
                                    <td>GIN index + JSONB <code>@&gt;</code> operator</td>
                                </tr>
                                <tr>
                                    <td>MongoDB</td>
                                    <td><span class="badge bg-success">✓ Supported</span></td>
                                    <td>Native <code>$eq</code>, <code>$gt</code>, <code>$in</code> queries</td>
                                </tr>
                                <tr>
                                    <td>SQLite</td>
                                    <td><span class="badge bg-success">✓ Supported</span></td>
                                    <td>JSON1 extension (<code>json_extract</code>)</td>
                                </tr>
                                <tr>
                                    <td>RocksDB</td>
                                    <td><span class="badge bg-danger">✗ Not Supported</span></td>
                                    <td>Key-value only → Must create Kuber indexes</td>
                                </tr>
                                <tr>
                                    <td>LMDB</td>
                                    <td><span class="badge bg-danger">✗ Not Supported</span></td>
                                    <td>Key-value only → Must create Kuber indexes</td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <h6 class="mt-3">Hybrid Query Configuration</h6>
                        <pre class="bg-dark text-light p-3 rounded"><code># Enable native DB query fallback when no Kuber index exists
kuber.indexing.hybrid-query-enabled=true

# Only use native queries if region has more entries than threshold
kuber.indexing.hybrid-query-threshold=10000</code></pre>
                        
                        <!-- Architecture Diagram -->
                        <h5 class="mt-4"><i class="fas fa-sitemap me-2 text-secondary"></i>Architecture</h5>
                        <pre class="bg-dark text-light p-3 rounded"><code>┌─────────────────────────────────────────────────────────────────────┐
│                         KUBER v2.3.0                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────┐    ┌─────────────────┐    ┌────────────────┐  │
│  │   API Request   │───▶│  Query Planner  │───▶│ Index Manager  │  │
│  └─────────────────┘    └─────────────────┘    └───────┬────────┘  │
│                                                        │           │
│                         ┌──────────────────────────────┤           │
│                         │                              │           │
│                         ▼                              ▼           │
│  ┌─────────────────────────────────────────┐  ┌─────────────────┐ │
│  │         In-Memory Indexes               │  │  Full Scan      │ │
│  │                                         │  │  (fallback)     │ │
│  │  ┌────────┐ ┌───────┐ ┌───────────────┐ │  └─────────────────┘ │
│  │  │  HASH  │ │ BTREE │ │    TRIGRAM    │ │                      │
│  │  │  O(1)  │ │O(logn)│ │ regex/contains│ │                      │
│  │  └────────┘ └───────┘ └───────────────┘ │                      │
│  │                                         │                      │
│  │            ┌────────────────┐           │                      │
│  │            │     PREFIX     │           │                      │
│  │            │  starts-with   │           │                      │
│  │            └────────────────┘           │                      │
│  └──────────────┬──────────────────────────┘                      │
│                 │                                                  │
│                 ▼                                                  │
│  ┌─────────────────────────────────┐                              │
│  │   RocksDB Index Persistence     │                              │
│  │   (hybrid mode)                 │                              │
│  └─────────────────────────────────┘                              │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘</code></pre>
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
</main>

<footer th:replace="~{layout :: footer}"></footer>

<script th:replace="~{layout :: scripts}"></script>
</body>
</html>
